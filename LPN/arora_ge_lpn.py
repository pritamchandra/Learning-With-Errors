# ________________________________________________ Library Imports

from sage.all import *
from itertools import product
from scipy.linalg import solve
from scipy.special import binom
from math import prod

import numpy as np
import galois

from helper import *

# _________________________________________________________ Arora-Ge methods

def Oracle(u, P, eta = None):
    '''This is an oracle for the LPN problem. Given polynomial P and 
    a secret vector u, return A and b, where A is a random m x n matrix, 
    and b = A @ u + eta, where eta is an arbitrary root of P.
    '''
    n = u.shape[0]
    field = P.parent().base_ring()

    while eta is None:
        # keep searching until a root of P is found
        eta = Random_root(P) 
    
    m = eta.shape[0]

    A = np.random.choice(field, size = (m, n))
    b = A @ u + eta

    return A, b

def Linearize(A, b, P, basis = None, 
                       print_constraint = False, 
                       multilinear_reduction = True):
    ''' HELPER TO LINEARIZE_BATCH
    This is the key step of the Arora-Ge algorithm. A and b are oracle 
    outputs where b = A @ u + eta, where u is a secret vector and the 
    noise eta is a root of the polynomial P of degree d. 

    The function uses the constraint P(A @ z + b) = 0 which has u as 
    a solution, and returns a linear system in the variables which 
    are all monomials of degree <= d in the z_i's.

    It is good practice to supply the "basis" of the monomials 
    for efficiency. 

    If "print_constraint" is enabled then the polynomial constraint 
    is printed.

    If "multilinear_reduction" is enabled, then the polynomial constraint
    is reduced to its multilinear form. (this is only valid for q = 2)
    '''
    m, n = A.shape
    d = P.degree()

    if basis is None: 
        # this is the basis of monomials of degree <= d in the z_i's
        basis = All_monoms(z, d, mutilinear_only = multilinear_reduction)

    R_z = basis[0].parent() # extracting the parent ring of the basis
    z = basis[ :n] # extract the z_i's from the basis

    P_z = P(list(A @ z - b)) # original polynomial constraint

    # NOTE: The following step is the key. This ONLY works when q = 2
    # Since z_i^k = z_i, we will convert P_z into a multilinear polynomial 
    if multilinear_reduction:
        P_z = R_z(sum([prod(monom.variables()) for monom in P_z.monomials()]))

    if print_constraint: # print if asked for
        print("Polynomial constraint: ", P_z)

    # convert the polynomial P_z into its vector representation
    coefficients = np.array([GF(2).zero()] * basis.shape[0]) # what is q
    monoms = P_z.monomials()
    for monom in monoms:
        # find the index of the monomial in the basis
        coefficients[basis == monom] = GF(2)(1)

    return coefficients

def Linearize_batch(u, P, sample_size, randomize_eta = True,
                                       multilinear_reduction = True,
                                       print_constraints = False):
    '''For an oracle output A, b, this function generates "sample_size"
     many samples of the LPN problem, and returns the matrix of 
     coefficients from the linearized problems, by using "Linearize" 
     as a subroutine. 

    "randomize_eta" is to give the user to fix the noise across all 
    samples. If not, it is generated by the oracle as a random root 
    of P for each sample. This is the generality which the algorithm
    is able to handle.

    "multilinear_reduction" is to reduce the polynomial constraint to
     its multilinear form when q = 2. This is a part of the Arora-Ge 
     algorithm, though one can disable it for testing on other values 
     of q.

    "print_constraints" is to explicitly print the polynomial constraints. 
    '''
    n = u.shape[0]
    m = P.parent().ngens()
    d = P.degree()

    R_z = PolynomialRing(GF(2), n, names = 'z') # parent ring
    z = np.array(R_z.gens()) # variables
    print("Generating ring basis.")
    basis = All_monoms(z, d, mutilinear_only = multilinear_reduction) 
    # print("Ring basis = %s\n" % basis)

    Coefficient_matrix = []
    # if eta is given it can be kept constant across the entire batch
    eta = None if randomize_eta else Random_root(P) # note here that 
    # Random_root(P) on rare ocassions may noy find a root, in which case
    # eta will vary across the samples. 

    print("Linearizing samples ...", end = " ")
    # generate the samples
    for i in range(1, sample_size + 1):
        A, b = Oracle(u, P, eta = eta)
        # each sample gives a vector as a linear constraint
        # the entire batch will give a system of constraints represented 
        # as a matrix. The solution is embedded in the kernel of this matrix
        Coefficient_matrix.append(Linearize(A, b, P, basis = basis, 
                                                     print_constraint = print_constraints))

        if i%50 == 0: print(i, end = "...") # print the progress

    print("%s." % sample_size)
    return np.array(Coefficient_matrix)